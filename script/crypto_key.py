#! /usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import codecs
import json
import re
import argparse
import logging
from logging import info, warning, error
from collections import OrderedDict

def generate_cpp_header(src_file, dest_file, variable_name):
    key = None
    with open(src_file, 'r') as f:
        key = f.read().strip()

    s = "// generated by crypto_key.py\n\n"
    s += "namespace kms {\n"
    s += "  static constexpr const char* "+variable_name+' = "'+key+'";\n'
    s += "}\n"

    with open(dest_file, 'w') as f:
        f.write(s)
    return True

# ---
# main function
#
if __name__ == '__main__':
    sys.stdout = codecs.lookup('utf_8')[-1](sys.stdout)
    logging.basicConfig(level = logging.INFO, format = '%(asctime)-15s %(levelname)s %(message)s')
    parser = argparse.ArgumentParser(description = 'generate crypto keys (AES-256-CBC)')
    parser.add_argument('src_aes_key_text', metavar = 'aes_256_key.txt', help = 'src AES-256-CBC password text (32byte)')
    parser.add_argument('src_aes_iv_text',  metavar = 'aes_iv.txt',   help = 'src AES Initial Vector text (16byte)')
    parser.add_argument('dest_aes_key_header', metavar = 'AesKey.h', help = 'dest AES key C++ header file')
    parser.add_argument('dest_aes_iv_header',  metavar = 'AesIv.h',   help = 'dest AES IV C++ heade file')
    args = parser.parse_args()

    info("input aes_256_key.txt = %s" % args.src_aes_key_text)
    info("input aes_iv.txt = %s" % args.src_aes_iv_text)
    info("output AesKey.h = %s" % args.dest_aes_key_header)
    info("output AesIv.h = %s" % args.dest_aes_iv_header)

    generate_cpp_header(args.src_aes_key_text, args.dest_aes_key_header, 'AES_KEY')
    generate_cpp_header(args.src_aes_iv_text,  args.dest_aes_iv_header,  'AES_IV')
    exit(0)
