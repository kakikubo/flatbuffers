#! /usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import codecs
import json
import re
import datetime
import argparse
import logging
from logging import info, warning, error
from collections import OrderedDict


def attribute_str(attributes):
    if attributes:
        attrs = []
        for k, v in attributes.iteritems():
            if v == True:
                attrs.append(k)
            elif isinstance(v, dict):
                attr = []
                for kk, vv in v.iteritems():
                    attr.append('%s:%s' % (kk, vv))
                attrs.append('%s:"%s"' % (k, ','.join(attr)))
            elif re.match('^[.0-9]+$', v) or v in ('true', 'false'):
                attrs.append(k+':'+v)
            else:
                attrs.append('%s:"%s"' % (k,v))
        return ' ('+', '.join(attrs)+')' if attrs else ''
    else:
        return ''

def collect_attributes(json_data):
    attribute_map = OrderedDict()
    for table_name in json_data:
        if "is_enum" in json_data[table_name] and json_data[table_name]["is_enum"]:
            continue
        for item in json_data[table_name]:
            if not item["attribute"]:
                continue
            for attribute in item["attribute"]:
                for k, v in item["attribute"].iteritems():
                    if not attribute_map.has_key(k):
                        attribute_map[k] = 0
                    attribute_map[k] += 1
    return attribute_map

def build_fbs_enum(name, body):
    def typed_format(tt):
        return "    %s = " + ("%.1f" if tt == "float" else "%d")
    buf = "enum %s : %s {\n" % (name, body["type"])
    enum_values = [typed_format(body["type"]) % (v["key"].upper(), v["value"])
                   for k, v in body["values"].items()]
    buf += ",\n".join(enum_values)
    buf += "\n}\n\n"
    return buf

def generate_fbs(root_name, namespace, json_data):
    s = "// generated by json2fbs.py\n\n"

    # output namespace
    s += "namespace {0};\n".format(namespace)

    # collect attributes
    s += "\n"
    fbs_reserved_attributes = ('id', 'deprecated', 'required', 'original_order', 'force_align', 'bit_flags', 'nested_flatbuffer', 'key', 'hash')
    attribute_map = collect_attributes(json_data)
    for k, v in attribute_map.iteritems():
        if not k in fbs_reserved_attributes:
            s += 'attribute "%s";\n' % k
    s += "\n"

    # output tables
    for table_name in json_data:
        if "is_enum" in json_data[table_name] and json_data[table_name]["is_enum"]:
            s += build_fbs_enum(table_name, json_data[table_name])
            continue
        if table_name == "_meta":
            s += 'table ' + root_name[0:1].upper() + root_name[1:] + " {\n"
        else:
            s += 'table ' + table_name[0:1].upper() + table_name[1:] + " {\n"
        for item in json_data[table_name]:
            if 'srcType' in item.keys() and item['srcType'] == 'enum':
                continue
            type_str = '['+item["type"]+']' if item['is_vector'] else item["type"];
            s += "    " + item["name"] + ":" + type_str + attribute_str(item["attribute"]) + ";\n"
        s += "}\n\n"

    # output root_type
    s += 'root_type {0};'.format(root_name)+"\n"
    return s

# ---
# root function
#
def json2fbs(input_json, output_fbs, root_name, namespace):
    with open(input_json, 'r') as f:
        json_data = json.loads(f.read(), object_pairs_hook=OrderedDict)
        if isinstance(json_data, dict):
            s = generate_fbs(root_name, namespace, json_data)
            with open(output_fbs, 'w') as f:
                f.write(s.encode('utf-8'))
        else:
            print 'unsupported format. params:[{0}][{1}][{2}]'.format(input_json, root_name, namespace)

# ---
# main function
#
if __name__ == '__main__':
    sys.stdout = codecs.lookup('utf_8')[-1](sys.stdout)
    parser = argparse.ArgumentParser(description = 'generate flatbuffers schema file (fbs) from json')
    parser.add_argument('input_json',  metavar = 'input.json',     help = 'input schema json file')
    parser.add_argument('output_fbs',  metavar = 'output.fbs',     help = 'output fbs file')
    parser.add_argument('--root-name', default = 'MasterDataFBS',  help = 'root node of flat buffers')
    parser.add_argument('--namespace', default = 'kms.masterdata', help = 'name space')
    parser.add_argument('--log-level', help = 'log level (WARNING|INFO|DEBUG). default: INFO')
    args = parser.parse_args()
    logging.basicConfig(level = args.log_level or "INFO", format = '%(asctime)-15s %(process)d %(levelname)s %(message)s')

    info("input.json = %s" % args.input_json)
    info("output.fbs = %s" % args.output_fbs)
    info("root name = %s" % args.root_name)
    info("namespace = %s" % args.namespace)
    json2fbs(args.input_json, args.output_fbs, args.root_name, args.namespace)
    exit(0)
